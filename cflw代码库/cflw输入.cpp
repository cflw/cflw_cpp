#include <assert.h>
#include "cflw输入.h"
namespace cflw::输入 {
void f重分配(bool *&a指针, t数量 a数量) {
	delete[] a指针;
	a指针 = new bool[a数量];
	memset(a指针, 0, a数量);
}
bool fi死区3(float x, float y, float z, float da) {
	return sqrtf(x * x + y * y + z * z) <= da;
}
//==============================================================================
// 按键
//==============================================================================
S按键::S按键(bool a这次, bool a上次):
	m这次(a这次),
	m上次(a上次) {
}
S按键::operator bool() const {
	return m这次;
}
bool S按键::fi刚按下() const {
	return m这次 && !m上次;
}
bool S按键::fi刚松开() const {
	return !m这次 && m上次;
}
bool S按键::fi按下() const {
	return m这次;
}
bool S按键::fi松开() const {
	return !m这次;
}
bool S按键::fi持续() const {
	return m这次 == m上次;
}
bool S按键::fi变化() const {
	return m这次 != m上次;
}
void S按键::f覆盖上次() & {
	m上次 = m这次;
}
//==============================================================================
// 方向
//==============================================================================
S方向::S方向(float X, float Y, float Z):
	x{X},
	y{Y},
	z{Z} {
}
bool S方向::fi左() const {
	return x < 0;
}
bool S方向::fi右() const {
	return x > 0;
}
bool S方向::fi上() const {
	return y > 0;
}
bool S方向::fi下() const {
	return y < 0;
}
bool S方向::fi前() const {
	return z > 0;
}
bool S方向::fi后() const {
	return z < 0;
}
bool S方向::fi死区(float da) const {
	return fi死区3(x, y, z, da);
}
//==============================================================================
// 按键
//==============================================================================
C按键组::C按键组(t数量 a数量):
	m分配数量(a数量), 
	m使用数量(a数量),
	m这次(new bool[a数量]),
	m上次(new bool[a数量]) {
}
C按键组::~C按键组() {
	delete[] m这次;
	delete[] m上次;
}
void C按键组::f重置数量(t数量 n) {
	if (m分配数量 < n) {
		f重分配(m这次, n);
		f重分配(m上次, n);
		m分配数量 = n;
	}
	m使用数量 = n;
}
t数量 C按键组::fg数量() const {
	return m使用数量;
}
S按键 C按键组::fg按键(t索引 i) const {
	assert(i < m分配数量);
	return S按键{m这次[i], m上次[i]};
}
void C按键组::f覆盖上次() {
	memcpy(m上次, m这次, m使用数量);
}
void C按键组::f清空上次() {
	memset(m上次, 0, m使用数量);
}
void C按键组::f清空这次() {
	memset(m这次, 0, m使用数量);
}
//==============================================================================
// 缓冲按键
//==============================================================================
C缓冲按键组::C缓冲按键组(t数量 a数量):
	m分配数量(a数量),
	m使用数量(a数量),
	m立即(new bool[a数量]), 
	m缓冲(new bool[a数量]) {
	f清空();
}
C缓冲按键组::~C缓冲按键组() {
	delete[] m立即;
	delete[] m缓冲;
}
void C缓冲按键组::f重置数量(t数量 n) {
	if (m分配数量 < n) {
		f重分配(m立即, n);
		f重分配(m缓冲, n);
		m分配数量 = n;
	}
	m使用数量 = n;
}
t数量 C缓冲按键组::fg数量() const {
	return m使用数量;
}
void C缓冲按键组::f按下(t索引 a按键) {
	m立即[a按键] = true;
	m缓冲[a按键] = true;
}
void C缓冲按键组::f松开(t索引 a按键) {
	m立即[a按键] = false;
}
void C缓冲按键组::f复制到按键(C按键组 &a按键) {
	assert(m使用数量 <= a按键.m分配数量);
	memcpy(a按键.m这次, m缓冲, m使用数量);
	memcpy(m缓冲, m立即, m使用数量);
}
void C缓冲按键组::f清空() {
	memset(m立即, 0, m使用数量);
	memset(m缓冲, 0, m使用数量);
}
//一个按键
void C缓冲按键::f按下() {
	m立即 = true;
	m缓冲 = true;
}
void C缓冲按键::f松开() {
	m立即 = false;
}
void C缓冲按键::f复制到按键(S按键 &a按键) {
	a按键.m这次 = m缓冲;
	m缓冲 = m立即;
}
void C缓冲按键::f清空() {
	m立即 = false;
	m缓冲 = false;
}
//==============================================================================
// 缓冲方向
//==============================================================================
C缓冲方向2::C缓冲方向2():
	m这次(), m上次() {
}
S方向 C缓冲方向2::fg这次方向() const {
	return S方向{m这次[0], m这次[1], 0};
}
S方向 C缓冲方向2::fg上次方向() const {
	return S方向{m上次[0], m上次[1], 0};
}
S方向 C缓冲方向2::fg方向差() const {
	return S方向{m这次[0] - m上次[0], m这次[1] - m上次[0], 0};
}
void C缓冲方向2::f覆盖上次() & {
	m上次[0] = m这次[0];
	m上次[1] = m这次[1];
}
void C缓冲方向2::f清空这次() & {
	m这次[0] = 0;
	m这次[1] = 0;
}
//==============================================================================
// 方向
//==============================================================================
C方向3::C方向3() {
	m方向[0] = m方向[1] = m方向[2] = 0;
}
S方向 C方向3::fg方向() const {
	return S方向{m方向[0], m方向[1], m方向[2]};
}
bool C方向3::fi死区(float da) const {
	return fi死区3(m方向[0], m方向[1], m方向[2], da);
}
//==============================================================================
// 映射
//==============================================================================
template<typename t接口> void f按键映射更新接口(C按键映射 &a映射, const t接口 &a接口) {
	for (const auto &[v源, v目标] : a映射.ma映射) {
		const S按键 v按键 = a接口.fg按键(v目标);
		a映射.m按键.m这次[v源] = v按键.m这次;
		a映射.m按键.m上次[v源] = v按键.m上次;
	}
}
C按键映射::C按键映射() {
}
C按键映射::~C按键映射() {
}
S按键 C按键映射::fg按键(t索引 i) const {
	return m按键.fg按键(i);
}
void C按键映射::f更新(const C按键组 &a按键) {
	for (const auto &[v源, v目标] : ma映射) {
		m按键.m这次[v源] = a按键.m这次[v目标];
		m按键.m上次[v源] = a按键.m上次[v目标];
	}
}
void C按键映射::f更新(const I键盘 &a键盘) {
	f按键映射更新接口(*this, a键盘);
}
void C按键映射::f更新(const I鼠标 &a鼠标) {
	f按键映射更新接口(*this, a鼠标);
}
void C按键映射::f更新(const I手柄 &a手柄) {
	f按键映射更新接口(*this, a手柄);
}
void C按键映射::fs映射(t索引 a0, t索引 a1) {
	ma映射[a0] = a1;
}
//==============================================================================
// 方向键
//==============================================================================
C方向键::C方向键(t索引 a正, t索引 a反):
	m方向{0}, 
	m正向键{a正}, 
	m反向键{a反} {
}
float C方向键::f计算(float a方向, const S按键 &a正向键, const S按键 &a反向键) {
	if (a方向 == 0) {
		if (a正向键.fi按下()) {
			return 1;
		} else if (a反向键.fi按下()) {
			return -1;
		}
	} else if (a方向 > 0) {
		if (a反向键.fi刚按下()) {
			return -1;
		} else if (a正向键.fi松开()) {
			return 0;
		}
	} else {//p < 0
		if (a正向键.fi刚按下()) {
			return 1;
		} else if (a反向键.fi松开()) {
			return 0;
		}
	}
	return a方向;
}
void C方向键::f更新(const C按键组 &a按键) {
	const S按键 v正向键 = a按键.fg按键(m正向键);
	const S按键 v反向键 = a按键.fg按键(m反向键);
	m方向 = f计算(m方向, v正向键, v反向键);
}
void C方向键::f更新(I键盘 &a键盘) {
	const S按键 v正向键 = a键盘.fg按键(m正向键);
	const S按键 v反向键 = a键盘.fg按键(m反向键);
	m方向 = f计算(m方向, v正向键, v反向键);
}
void C方向键::fs正反键(t索引 a正, t索引 a反) {
	m正向键 = a正;
	m反向键 = a反;
}
//==============================================================================
// 按住重复
//==============================================================================
std::tuple<bool, S按键> C互斥键::f计算(const S按键 &a正, const S按键 &a反) {
	if (a正.fi刚按下()) {
		m键 = true;
		return {m键, a正};
	} else if (a反.fi刚按下()) {
		m键 = false;
		return {m键, a反};
	}
	const S按键 &v引用 = (m键 ? a正 : a反);
	return {m键, v引用};
}
//==============================================================================
// 按住重复
//==============================================================================
C按住重复::C按住重复(float a延迟, float a间隔):
	m延迟(a延迟), m间隔(a间隔) {
}
void C按住重复::fs重置时间(float a延迟, float a间隔) {
	m次数 = 0;
	m时间 = 0;
	m延迟 = a延迟;
	m间隔 = a间隔;
}
bool C按住重复::f滴答(const S按键 &a按键, float a时间) {
	if (a按键.fi刚按下()) {
		m次数 = 0;
		m时间 = 0;
		return true;
	} else if (a按键.fi按下()) {
		auto f比较 = [this](float a间隔) {
			if (m时间 >= a间隔) {
				++m次数;
				m时间 = 0;
				return true;
			} else {
				return false;
			}
		};
		m时间 += a时间;
		if (m次数) {
			return f比较(m间隔);
		} else {
			return f比较(m延迟);
		}
	} else {
		return false;
	}
}
}	//namespace cflw::输入