#include <assert.h>
#include "cflw输入.h"
namespace cflw::输入 {
//==============================================================================
// 按键
//==============================================================================
S按键::S按键(bool a这次, bool a上次):
	m这次(a这次),
	m上次(a上次) {
}
S按键::operator bool() const {
	return m这次;
}
bool S按键::f刚按下() const {
	return m这次 && !m上次;
}
bool S按键::f刚松开() const {
	return !m这次 && m上次;
}
bool S按键::f按下() const {
	return m这次;
}
bool S按键::f松开() const {
	return !m这次;
}
bool S按键::f持续() const {
	return m这次 == m上次;
}
bool S按键::f变化() const {
	return m这次 != m上次;
}
void S按键::f覆盖上次() & {
	m上次 = m这次;
}
//==============================================================================
// 方向
//==============================================================================
S方向::S方向(float X, float Y, float Z):
	x{X},
	y{Y},
	z{Z} {
}
bool S方向::f左() const {
	return x < 0;
}
bool S方向::f右() const {
	return x > 0;
}
bool S方向::f上() const {
	return y > 0;
}
bool S方向::f下() const {
	return y < 0;
}
bool S方向::f前() const {
	return z > 0;
}
bool S方向::f后() const {
	return z < 0;
}
//==============================================================================
// 按键
//==============================================================================
C按键组::C按键组(t数量 a数量):
	m数量(a数量), 
	m这次(new bool[a数量]), 
	m上次(new bool[a数量]) {
}
C按键组::~C按键组() {
	delete[] m这次;
	delete[] m上次;
}
S按键 C按键组::f按键(t索引 i) const {
	assert(i < m数量);
	return S按键{m这次[i], m上次[i]};
}
void C按键组::f覆盖上次() {
	memcpy(m上次, m这次, m数量);
}
void C按键组::f清空上次() {
	memset(m上次, 0, m数量);
}
void C按键组::f清空这次() {
	memset(m这次, 0, m数量);
}
//==============================================================================
// 缓冲按键
//==============================================================================
C缓冲按键组::C缓冲按键组(t数量 a数量):
	m数量(a数量), 
	m立即(new bool[a数量]), 
	m缓冲(new bool[a数量]) {
	f清空();
}
C缓冲按键组::~C缓冲按键组() {
	delete[] m立即;
	delete[] m缓冲;
}
void C缓冲按键组::f按下(t索引 a按键) {
	m立即[a按键] = true;
	m缓冲[a按键] = true;
}
void C缓冲按键组::f松开(t索引 a按键) {
	m立即[a按键] = false;
}
void C缓冲按键组::f复制到按键(C按键组 &a按键) {
	assert(m数量 <= a按键.m数量);
	memcpy(a按键.m这次, m缓冲, m数量);
	memcpy(m缓冲, m立即, m数量);
}
void C缓冲按键组::f清空() {
	memset(m立即, 0, m数量);
	memset(m缓冲, 0, m数量);
}
//一个按键
void C缓冲按键::f按下() {
	m立即 = true;
	m缓冲 = true;
}
void C缓冲按键::f松开() {
	m立即 = false;
}
void C缓冲按键::f复制到按键(S按键 &a按键) {
	a按键.m这次 = m缓冲;
	m缓冲 = m立即;
}
void C缓冲按键::f清空() {
	m立即 = false;
	m缓冲 = false;
}
//==============================================================================
// 缓冲方向
//==============================================================================
C缓冲方向2::C缓冲方向2() {
	m这次[0] = 0;
	m这次[1] = 0;
	m上次[0] = 0;
	m上次[1] = 0;
}
S方向 C缓冲方向2::f这次方向() const {
	return S方向{m这次[0], m这次[1], 0};
}
S方向 C缓冲方向2::f上次方向() const {
	return S方向{m上次[0], m上次[1], 0};
}
S方向 C缓冲方向2::f方向差() const {
	return S方向{m这次[0] - m上次[0], m这次[1] - m上次[0], 0};
}
void C缓冲方向2::f覆盖上次() {
	m上次[0] = m这次[0];
	m上次[1] = m这次[1];
}
void C缓冲方向2::f清空这次() {
	m这次[0] = 0;
	m这次[1] = 0;
}
//==============================================================================
// 方向
//==============================================================================
C方向3::C方向3() {
	m方向[0] = m方向[1] = m方向[2] = 0;
}
S方向 C方向3::f方向() const {
	return S方向{m方向[0], m方向[1], m方向[2]};
}
//==============================================================================
// 映射
//==============================================================================
template<typename t接口> void f按键映射更新接口(C按键映射 &a映射, const t接口 &a接口) {
	for (t索引 i = 0; i != C按键映射::c映射数量; ++i) {
		const S按键 v按键 = a接口.f按键(a映射.m映射表[i]);
		a映射.m按键.m这次[i] = v按键.m这次;
		a映射.m按键.m上次[i] = v按键.m上次;
	}
}
C按键映射::C按键映射() {
}
C按键映射::~C按键映射() {
}
S按键 C按键映射::f按键(t索引 i) const {
	return m按键.f按键(i);
}
void C按键映射::f更新(const C按键组 &a按键) {
	for (t索引 i = 0; i != c映射数量; ++i) {
		const t索引 v映射 = m映射表[i];
		m按键.m这次[i] = a按键.m这次[v映射];
		m按键.m上次[i] = a按键.m上次[v映射];
	}
}
void C按键映射::f更新(const I键盘 &a键盘) {
	f按键映射更新接口(*this, a键盘);
}
void C按键映射::f更新(const I鼠标 &a鼠标) {
	f按键映射更新接口(*this, a鼠标);
}
void C按键映射::f更新(const I手柄 &a手柄) {
	f按键映射更新接口(*this, a手柄);
}
void C按键映射::fs映射(t索引 a0, t索引 a1) {
	m映射表[a0] = a1;
}
//==============================================================================
// 方向键
//==============================================================================
C方向键::C方向键(t索引 a正, t索引 a反):
	m方向{0}, 
	m正向键{a正}, 
	m反向键{a反} {
}
float C方向键::f计算(float a方向, const S按键 &a正向键, const S按键 &a反向键) {
	if (a方向 == 0) {
		if (a正向键.f按下()) {
			return 1;
		} else if (a反向键.f按下()) {
			return -1;
		}
	} else if (a方向 > 0) {
		if (a反向键.f刚按下()) {
			return -1;
		} else if (a正向键.f松开()) {
			return 0;
		}
	} else {//p < 0
		if (a正向键.f刚按下()) {
			return 1;
		} else if (a反向键.f松开()) {
			return 0;
		}
	}
	return a方向;
}
void C方向键::f更新(const C按键组 &a按键) {
	const S按键 v正向键 = a按键.f按键(m正向键);
	const S按键 v反向键 = a按键.f按键(m反向键);
	m方向 = f计算(m方向, v正向键, v反向键);
}
void C方向键::f更新(I键盘 &a键盘) {
	const S按键 v正向键 = a键盘.f按键(m正向键);
	const S按键 v反向键 = a键盘.f按键(m反向键);
	m方向 = f计算(m方向, v正向键, v反向键);
}
void C方向键::fs正反键(t索引 a正, t索引 a反) {
	m正向键 = a正;
	m反向键 = a反;
}
}	//namespace cflw::输入